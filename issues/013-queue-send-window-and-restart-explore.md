# 探索：重启不批量发送 + 贴近设定时间发送

## 你的两点担心（原始）

1. **重启后的批量发送**：程序出问题重启时，若所有邮件的 Planned Send At 都小于当前时间，会变成「批量发送」，不符合要求。
2. **贴近设定时间发送**：希望发送时机尽量接近 Planned Send At。

## 你已确认的规则

1. **过期项**：不丢弃。拿到过期任务后**慢慢消化**：随机 **3～5 分钟** 发一封，**每小时最多 10 封**，**每天最多 50 封**；需**全局配置**（对所有 Queue 行业生效）。
2. **「发送窗口」是什么**：见下节说明；实现里用窗口区分「准时」与「过期」。
3. **贴近程度**：接受**到点后 1 分钟内发出**；需注意与过期项任务的**冲突**（下面用「准时优先 + 共用限额」处理）。
4. **轮询间隔**：接受默认 **1 分钟**。

---

## 「发送窗口」简单说明

**发送窗口** = 「计划发送时间」之后的**一段时间**，在这段时间内我们仍把这条当作**准时**发送。

- **窗口内（准时）**：`plannedSendAt <= now <= plannedSendAt + W`（W 如 2 分钟）。这类在本轮或下一轮**立即发**，保证「1 分钟内发出」。
- **窗口外（过期）**：`now > plannedSendAt + W`。这类**不立刻发**，进入**慢消化**：随机 3～5 分钟发一封，且受「每小时 10、每天 50」限制。

这样既避免重启后一次性发完所有过期项，又保证「快到点的」在 1 分钟内发出。实现时 W 可取 2 分钟（可配置），配合 1 分钟轮询即可。

---

## 行为与冲突处理

- **每 1 分钟**跑一轮（可配置）。
- **本轮待发项**分两类：
  - **准时**：`plannedSendAt <= now <= plannedSendAt + W`（W 默认 2 分钟）。
  - **过期**：`now > plannedSendAt + W`。
- **发送顺序与限额**：
  - **先发所有准时项**（本轮内发完，保证 1 分钟内发出；若数量多可仍受现有 batchSize 或单轮上限约束，避免单轮爆量）。
  - **再发过期项**：每轮最多发 **1 封**，且需同时满足：
    - 距**上一封过期发送**已过 **3～5 分钟**（随机）；
    - 本小时已发过期数 **< 10**；
    - 今天已发过期数 **< 50**。
- **冲突**：准时与过期**共用**「每小时 10、每天 50」还是**分开**？建议**共用**：即「每小时最多 10 封」「每天最多 50 封」指**所有**本进程发出的邮件（准时 + 过期），这样逻辑简单，且不会出现「准时很多 + 过期很多」导致单小时/单日超发。若你希望过期单独限额，可再说明。
- **全局**：上述 3～5 分钟、10/小时、50/天 为**进程级**配置，对所有 Queue 行业一致（通过 env 配置）。

---

## 全局配置项（env，建议）

| 变量 | 含义 | 建议默认 |
|------|------|----------|
| `QUEUE_BATCH_INTERVAL_MS` | 轮询间隔（毫秒） | 60000（1 分钟） |
| `QUEUE_SEND_WINDOW_MINUTES` | 发送窗口 W（分钟），窗口内=准时 | 2 |
| `QUEUE_OVERDUE_MIN_INTERVAL_MS` | 两封过期邮件最小间隔（毫秒） | 3*60*1000（3 分钟） |
| `QUEUE_OVERDUE_MAX_INTERVAL_MS` | 两封过期邮件最大间隔（毫秒） | 5*60*1000（5 分钟） |
| `QUEUE_OVERDUE_MAX_PER_HOUR` | 每小时最多发几封（与准时共用） | 10 |
| `QUEUE_OVERDUE_MAX_PER_DAY` | 每天最多发几封（与准时共用） | 50 |

「共用」表示：每小时/每天的总发送数（准时 + 过期）不超过上述值；若希望只对「过期」做 10/50 限制，需在实现时改为仅统计过期发送数。

---

## 实现要点（不实现，仅规划）

1. **notion-queue**  
   - 查询仍不包含 Planned Send At；应用内过滤时区分：  
     - 准时：`plannedSendAt <= now <= plannedSendAt + W`；  
     - 过期：`now > plannedSendAt + W`。  
   - 返回结构能区分两类（或返回两类列表），供 queue-sender 先处理准时、再处理过期。

2. **queue-sender**  
   - 轮询间隔从 env 读，默认 1 分钟。  
   - 每轮：  
     - 拉取待发项，按上述规则分为「准时」「过期」。  
     - 先发**所有**准时项（可保留单轮上限如 batchSize，避免单轮过多）。  
     - 再发**至多 1 封**过期项，需满足：距上次过期发送 ≥ 随机(3,5) 分钟，且本小时/今日发送数未超限。  
   - **进程内状态**（内存）：上次过期发送时间、本小时已发数、今日已发数；按自然小时/自然日滚动。进程重启后从 0 重新计，不影响「慢慢消化」（重启后仍按 3～5 分钟一封发过期）。

3. **配置与文档**  
   - env.example 与 README 中补充上述全局配置说明。

---

## 待你最终确认

1. **每小时 10 / 每天 50**：是**总发送数**（准时 + 过期）上限，还是**仅过期**的上限？当前按「总发送数」设计；若仅过期，需单独说明。
2. **准时项单轮上限**：是否保留「每轮最多发 batchSize 条」给准时项（避免某轮准时项特别多时一次发太多）？还是准时项不设上限，有多少发多少以保证 1 分钟内？

确认后即可按此方案实现。

---

## 方案 B：完全由程序控制发送节奏（按发送者区分）— 更简单

你提出：**不考虑 Queue 里的计划时间**，完全通过程序控制并判断「每一封应该什么时候发」，在既定规则下慢慢执行；且**不同发送者账号要区分开**。

### 思路对比

- **方案 A（上文）**：用 Notion 的 Planned Send At + 「发送窗口」区分「准时」与「过期」，准时立刻发、过期慢消化，逻辑有两套、状态也多。
- **方案 B**：**不再用 Planned Send At 决定发送时刻**（可选：仍用「计划时间 ≤ 当前时间」做「可发资格」，避免把「计划明天」的提前发）。**发送时机完全由程序规则决定**：每个**发送者账号**独立遵守「两封间隔 3～5 分钟、每小时最多 10、每天最多 50」。每轮（如 1 分钟）只做一件事：对每个发送者看是否「到了可发下一封的时间且未超限」，若是则从该发送者的待发里取 1 条发掉。无「准时/过期」两套逻辑，实现更简单。

### 行为简述（方案 B）

1. **拉取**：仍从 Notion 查 Pending 项（四 Flag、Subject/Body 等条件不变）。是否过滤 `plannedSendAt <= now` 可选：  
   - **完全不管计划时间**：所有 Pending 都可被程序排期发送（可能把「计划下周」的也很快发掉）。  
   - **仅作「不早于」**：只拉取 `plannedSendAt <= now`（或无计划时间）的项，不提前发「计划未来」的；发送先后与间隔仍完全由程序规则决定。
2. **按发送者分组**：待发项按 **Sender Account** 分组，每个发送者一个「待发队列」（如按 Queued At 或 Planned Send At 排序）。
3. **每发送者独立节奏**：每个发送者维护：  
   - 上次发送时间 `lastSendAt`  
   - 本小时已发数、今日已发数（按自然小时/自然日滚动）  
   规则：**两封间隔 3～5 分钟（随机）、每小时最多 10、每天最多 50**，且**按发送者分别统计**（A 和 B 各 10/小时、各 50/天）。
4. **每轮执行**：例如每 1 分钟跑一轮。对**每个发送者**：若该发送者有待发项，且 `now - lastSendAt >= 随机(3,5) 分钟`，且本小时/今日未超限，则从该发送者待发中取 **1 条**发送，更新该发送者的 `lastSendAt` 与计数。多发送者可在同一轮各发 1 封（互不占用对方的间隔与限额）。
5. **无「准时/过期」区分**：不区分「刚到点」和「早就过了」；所有可发项统一按「该发送者下一个可用时间槽」慢慢发，重启后也不会成批连发。

### 为何更简单

- 不再需要「发送窗口 W」「准时 vs 过期」两套分支和两套状态。
- 状态只有「按发送者」的：`lastSendAt`、本小时数、今日数。
- 每轮逻辑单一：对每个发送者判断「能否发 1 封」，能则发 1 条并更新该发送者状态。

### 你已确认（方案 B）

1. **Planned Send At 完全不参与**：所有 Pending（满足四 Flag、Subject/Body 等）都进入待发，程序按发送者节奏发；不读、不用计划时间。
2. **限额按发送者**：10/小时、50/天 **按发送者账号**（每个账号独立 10 和 50）。
3. **不需要固定轮询间隔**：见下节「按下次发送时间休眠」。

---

### 按下次发送时间休眠（无固定轮询间隔）

既然发送节奏完全由程序控制（每发送者 3～5 分钟一封、10/小时、50/天），可以**不设固定轮询间隔**，改为：

- 每个发送者维护 **下次可发时间** `nextSendAt`（= 上次发送时间 + 随机 3～5 分钟，且受 10/小时、50/天约束）。
- 本轮处理完后，**休眠时长 = 当前到「所有发送者中最早的 nextSendAt」的时长**；若没有任何待发项，则休眠一档固定时长（如 1 分钟）再拉一次 Notion，避免长期不拉新数据。
- 到点醒来后：拉取 Notion 待发项 → 按发送者分组 → 对「nextSendAt <= now」且未超限的发送者各发 1 条 → 更新各发送者的 nextSendAt 与计数 → 再算下一次休眠时长并 sleep。

这样由「下次发送时间」驱动唤醒，无需固定 1 分钟轮询；仅在没有待发项时用短间隔（如 1 分钟）定期拉 Notion。

---

### 实现时（方案 B）要点

- **notion-queue**：查询 Pending 时**不再过滤** `plannedSendAt <= now`（可仍读该字段用于日志或排序，但不参与「是否可发」）。其余过滤不变（Email Status、四 Flag、Subject/Body 非空等）。
- **queue-sender**：  
  - 按发送者维护：`lastSendAt`（或 `nextSendAt`）、本小时已发数、今日已发数。  
  - 主循环：拉取待发 → 按 sender 分组 → 对每个 sender 若 `now >= nextSendAt` 且未超 10/小时、50/天，则取 1 条发送并更新该 sender 状态 → 计算 `sleepMs = min(nextSendAt - now)`（有待发时）或 60_000（无待发时）→ sleep(sleepMs) → 重复。
- **配置**：间隔 3～5 分钟、10/小时、50/天 用 env 全局可配；限额按发送者。

确认后即可按方案 B 做实现设计（含配置项与 per-sender 状态）。
